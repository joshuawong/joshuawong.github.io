<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>Java-Question-Question | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="(1) 面向对象的特征有哪些方面？ 
   a. abstract: include data abstract and behavior abstract. Abstract only cares about object has what kinds of attributes and function, does not concern about details.
   b. encaps">
<meta property="og:type" content="article">
<meta property="og:title" content="Java-Question-Question">
<meta property="og:url" content="http://yoursite.com/2016/10/04/Java-Question/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="(1) 面向对象的特征有哪些方面？ 
   a. abstract: include data abstract and behavior abstract. Abstract only cares about object has what kinds of attributes and function, does not concern about details.
   b. encaps">
<meta property="og:updated_time" content="2016-10-08T17:37:57.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java-Question-Question">
<meta name="twitter:description" content="(1) 面向对象的特征有哪些方面？ 
   a. abstract: include data abstract and behavior abstract. Abstract only cares about object has what kinds of attributes and function, does not concern about details.
   b. encaps">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css">
</head>

  
    <body>
  
      <div id="container" class="container">
        <article id="post-Java-Question" class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
  <nav id="main-nav" class="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS"></a>
    
  </nav>
</header>

  <hr/>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java-Question-Question
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <p>(1) <strong>面向对象的特征有哪些方面？</strong> </p>
<p>   a. abstract: include data abstract and behavior abstract. Abstract only cares about object has what kinds of attributes and function, does not concern about details.</p>
<p>   b. encapsulate: hide everything can be hided from outer object, and provide simple API and function for outer object.</p>
<p>   c. inherit: extends from existing class. Subclass &amp; superclass. Extends from existing class, subclass can reuse functions and data in superclass as well as add its own new functions, but subclass cannot take away any fields or function of superclass. Subclass cannot access private variable in superclass.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* assume Employee class has a private attribute called salary; Manager extends from Employee, and has a attribute called bonus. There is a function called getSalary().*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> bonus + salary; <span class="comment">// this won't work.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   keyword: <strong><em>super</em></strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// here is the correct version</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> bonus + <span class="keyword">super</span>.salary; <span class="comment">// this won't work.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   Another usage of <strong><em>super</em></strong> is construction.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> bonus)</span></span>&#123;</div><div class="line">  <span class="keyword">super</span>(name, salary, year);</div><div class="line">  bonus = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   Subclass can be assigned to super class.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// example 1</span></div><div class="line">Employee someone = <span class="keyword">new</span> Manager(name, salary, year, bonus);</div><div class="line"><span class="comment">// example 2</span></div><div class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div></pre></td></tr></table></figure>
<p>   Keyword <strong><em>final</em></strong> can prevent override in inheritance. Function and field with <strong><em>final</em></strong> keyword cannot be overrided in subclass.</p>
<p>   d. polymorphism: enable same function can have different parameter list. Two ways to implement polymorphism: override(at compile time) and overload(at run time). </p>
<p>   ​</p>
<p>(2) <strong>访问修饰符public,private,protected,以及不写（默认）时的区别？</strong></p>
<table>
<thead>
<tr>
<th>keyword</th>
<th>same package</th>
<th>subclass</th>
<th>different package</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>private</td>
<td>true</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>deault</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>protected</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>(3) <strong>String 是最基本的数据类型吗？</strong> </p>
<p>   No. String is a reference type. Only 8 Primitive types. Except primitive types and enumeration type, the rest types are all reference type. </p>
<p>   primitive type is called by value; while reference type is called by reference.</p>
<p>   (which means using primitive variable as parameter to a function won’t change its value.)</p>
<p>   ​</p>
<p>(4) <strong>float f=3.4;是否正确？</strong></p>
<p>   No. Because 3.4 is double type. Cast double to float will cause accuracy problem. The correct ways are <strong>float x = (float)3.4</strong> or <strong>float x = 3.4F</strong></p>
<p>   ​</p>
<p>(5) <strong>short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？</strong> </p>
<p>   In the former case, it is wrong. 1 is int type, down-casting cause accuracy proble. The latter one is right. <strong>s1 +=1</strong> equals to <strong>s1 = (short)s1 + 1</strong>.</p>
<p>   ​</p>
<p>(6) <strong>Java有没有goto？</strong> </p>
<p>   There is no <strong><em>goto</em></strong> and <strong><em>const</em></strong> keyword in new version of java.</p>
<p>   ​</p>
<p>(7) <strong>int和Integer有什么区别？</strong></p>
<p>   <strong>int</strong> is primitive type, <strong>Integer</strong> is a class, so it is reference type. AutoBoxing(since Java 5).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoUnboxingTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</div><div class="line">        Integer b = <span class="number">3</span>;                  <span class="comment">// autoboxing 3 to Integer.</span></div><div class="line">        <span class="keyword">int</span> c = <span class="number">3</span>;</div><div class="line">        System.out.println(a == b);     <span class="comment">// false. two reference do not point to same object.</span></div><div class="line">        System.out.println(a == c);     <span class="comment">// true. a autoUnBoxing to int, then compare to c. </span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   An example of autoboxing in interview:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Integer f1 = <span class="number">100</span>, f2 = <span class="number">100</span>, f3 = <span class="number">150</span>, f4 = <span class="number">150</span>;</div><div class="line"></div><div class="line">        System.out.println(f1 == f2);  <span class="comment">// true</span></div><div class="line">        System.out.println(f3 == f4);  <span class="comment">// false</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   Here, the range of <strong>int</strong> is [-127, 128]. So if value of <strong>Integer</strong>in this range, java won’t auto boxing, instead, java will creat a <strong>int</strong> variable.  </p>
<p>   ​</p>
<p>(8) <strong>解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法。</strong></p>
<p>   stack: primitive variable, reference of object and invoke of function are stored in stack.</p>
<p>   heap: object created by <strong>new</strong> and constructor are stored in heap.</p>
<p>   static area: value of variable are stored in static area.</p>
<p>   Operations in stack are fast, but stack is small, so when using stack should avoid memory overflow. Usually, large objects are stored in heap.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String str = <span class="keyword">new</span> String(<span class="string">"Hello world"</span>);</div></pre></td></tr></table></figure>
<p>   In this example, <em>str</em> is stored in stack; <em>“Hello world”</em> is stored in static area; the object of String is stored in heap.</p>
<p>   ​</p>
<p>(9) <strong>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？</strong> </p>
<p>   The former one is 12, the latter one is -11. The rule of round() is +0.5 then rounding.</p>
<p>   ​</p>
<p>(10) <strong>switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？</strong></p>
<p>   switch(expr), expr can be byte, char, int, enum(java 5), String(java 7). But long is still not available in switch.</p>
<p>   ​</p>
<p>(11)  <strong>用最有效率的方法计算2乘以8？</strong> </p>
<p>   Bit manipulation. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>&lt;&lt;<span class="number">3</span></div></pre></td></tr></table></figure>
<p>   Why we always select 31 when overriding <strong>hashCode()</strong>, because <strong>31 * num</strong> equals to <strong>(num &lt;&lt; 5) - num</strong>. The latter one is much faster than the former one.</p>
<p>   ​</p>
<p>(12) <strong>构造器（constructor）是否可被重写（override）？</strong></p>
<p>   constructor cannot be overrided, but it can be overloaded.</p>
<p>   ​</p>
<p>(13) <strong>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</strong></p>
<p>   No. In <strong>equal()</strong> function, it requires hashCode of x should equals to hashCode of y. </p>
<p>   ​</p>
<p>(14) <strong>是否可以继承String类</strong></p>
<p>   No. <strong>String</strong> class is final.</p>
<p>   ​</p>
<p>(15) <strong>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</strong></p>
<p>   Call by value!!</p>
<p>   If primitive type, call by value, because variable value won’t change in origin object.</p>
<p>   If reference type, call by value, but parameter is a copy of variable address in momery. So the called function can change its value. <a href="http://blog.sina.com.cn/s/blog_4b622a8e0100c1bo.html" target="_blank" rel="external">reference</a></p>
<p>   ​</p>
<p>(16) <strong>String和StringBuilder、StringBuffer的区别？</strong></p>
<p>   The value of String cannot be modified directly. While, StringBuilder/StringBuffer’s value can modify directly. The difference between StringBuilder() and StringBuffer() is that StringBuilder() is used in single thread, it does’t contains <strong>synchronized</strong>, so its effectiveness is higher than StringBuffer(). This also means StringBuffer() is thread safety and StringBuilder isn’t.</p>
<p>   Interview Question 1: 什么情况下用+运算符进行字符串连接比调用StringBuffer/StringBuilder对象的append方法连接字符串性能更好？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String S1 = “This is only a” + “ simple” + “ test”;</div></pre></td></tr></table></figure>
<p>   JVM will view S1 as “This is only a simple test”, so in this case, String is more effective than StringBuilder().</p>
<p>   Interview Question 2: What is the output of this code?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringEqualTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String s1 = <span class="string">"Programming"</span>;</div><div class="line">        String s2 = <span class="keyword">new</span> String(<span class="string">"Programming"</span>);</div><div class="line">        String s3 = <span class="string">"Program"</span> + <span class="string">"ming"</span>;</div><div class="line">        System.out.println(s1 == s2); 				<span class="comment">// false</span></div><div class="line">        System.out.println(s1 == s3);				<span class="comment">// true</span></div><div class="line">        System.out.println(s1 == s1.intern());		<span class="comment">// true</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>(17) <strong>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</strong></p>
<p>   Overload is in the same class, one function can be written in serveral function with different parameter list. Override is in superclass and subclass, function in subclass rewrite the same function in superclass. (Here, override cannot claim more exception than its superclass)</p>
<p>   ​</p>
<p>(18) <strong>char 型变量中能不能存贮一个中文汉字，为什么?</strong></p>
<p>   Yes. Because in java, char is stored in Unicode. Chinese character is Unicode.</p>
<p>(19) <strong>抽象类（abstract class）和接口（interface）有什么异同？</strong> </p>
<p>   Abstract class can have instance methods that implement a default behavior. An interface can only  declare constants and instance methods.   ​</p>
<p>(20) <strong>Java 中会存在内存泄漏吗，请简单描述。</strong></p>
<p>   In general, Java won’t leak memory, because it has garbage collection mechanism. </p>
<p>(21) <strong>抽象的（abstract）方法是否可同时是静态的（static, 是否可同时被synchronized修饰？</strong> </p>
<p>   (1) abstract method cannot be static, because abstract method must be override, while static method cannot be override.</p>
<p>   (2) synchronized is depended on how the method implement, so without implementation detail, we can say a method is synchronized.</p>
<p>(22) <strong>阐述静态变量和实例变量的区别。</strong></p>
<p>   A static variable is associated with the class as a entire part rather than with specific instances of a class. Instantiated variable must reply on Instant.</p>
<p>(23) <strong>GC是什么？为什么要有GC？</strong></p>
<p>   Garbage collection. It uses garbage collection to free the memory. By cleaning those objects that is no longer reference by any of the program.</p>
<p>(24) <strong>String s = new String(“xyz”);创建了几个字符串对象？</strong> </p>
<p>   Two. One is “xyz” in static area; the other one is object <strong>s</strong> in heap.</p>
<p>(25) <strong>接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？</strong> </p>
<p>   (1) Yes, and interface enable multiple extends.</p>
<p>   (2) Abstract class can implements interface.</p>
<p>   (3) Abstract class can extends concrete class.</p>
<p>(26) <strong>一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</strong></p>
<p>   Yes. But in Java, one “.java” source file can only contain one public class, and the class name should be as same as file name.</p>
<p>(27) <strong>Java 中的final关键字有哪些用法？</strong></p>
<p>   (1) modify class: that class cannot be extended.</p>
<p>   (2) modify method: that method cannot be override.</p>
<p>   (3) modify variable: that variable cannot be changed once it is initialized.</p>
<p>(28) <strong>内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制?</strong></p>
<p>   <strong>A inner class can access all the outer class’s object, include private variable and object.</strong></p>
<p>(29) <strong>指出下面程序的运行结果。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> &#123;</div><div class="line">      System.out.print(<span class="string">"1"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.print(<span class="string">"2"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> &#123;</div><div class="line">      System.out.print(<span class="string">"a"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</div><div class="line">      System.out.print(<span class="string">"b"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      A ab = <span class="keyword">new</span> B();</div><div class="line">      ab = <span class="keyword">new</span> B();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">​</div></pre></td></tr></table></figure>
<p>   The output is 1a2b2b. The first line of main function return “1a2b”, and “1a” is static print. </p>
<p>(30) <strong>数据类型之间的转换：</strong> </p>
<p><strong>- 如何将字符串转换为基本数据类型？</strong><br> <strong>- 如何将基本数据类型转换为字符串？</strong> </p>
<p>   (1) In Integer/Long/Double/.. class, there are methods called parseXXX(String) or valurOf(String),, these methods can return primitive data type.</p>
<p>   (2) The first method is use empty string(“”) and +; the second method is to invoke function  calueOf() in String class. </p>
<p>(31) <strong>Error和Exception有什么区别？</strong></p>
<p>Error means exceptions or errors system won’t handle, and they are hard to recovered, like memory overflow. </p>
<p>Exception means exceptions or errors system should catch and handle, which means if the program goes right, these exception will never happen.</p>
<p>(32) <strong>try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?</strong> </p>
<p>It will be excuted. Before return. PS. It’s not a good idea to modify return value in finally block.  </p>
<p>(33) <strong>Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？</strong></p>
<p>Generally, use <strong>try</strong> to excute some code, if the system <strong>throw</strong> a exception, use <strong>catch</strong> to catch and handle the exception, or use <strong>finally</strong> block to handle. </p>
<p>try: points out a block of code will throw exception;</p>
<p>catch: follow after try, catch the exceptions you want;</p>
<p>throw: claim to throw a exception;</p>
<p>throws: claim a method may throw what kind of exception;</p>
<p>finally: guarente a block of code will be exceuted no matter there are exceptions or not. </p>
<p>(34) <strong>运行时异常与受检异常有何异同？</strong> </p>
<p>Runtime exception always caused by incorrect code, compiler exception always caused by relative code even your code is correct. </p>
<p>JVM requires compiler exceptions must be claimed using throw keyword, while runtime exception is not necessary.</p>
<p>(35) <strong>阐述final、finally、finalize的区别。</strong> </p>
<p>final: a modify keyword. </p>
<p>finally: a block after try..catch, will be exceuted all the time.</p>
<p>finalize: a object method. This method is used for destroying object by garbage collection.</p>
<p>(36) <strong>类ExampleA继承Exception，类ExampleB继承ExampleA。</strong><br><strong>有如下代码片断：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExampleB(<span class="string">"b"</span>)</div><div class="line">&#125; <span class="keyword">catch</span>（ExampleA e）&#123;</div><div class="line">    System.out.println(<span class="string">"ExampleA"</span>);</div><div class="line">&#125; <span class="keyword">catch</span>（Exception e）&#123;</div><div class="line">    System.out.println(<span class="string">"Exception"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>请问执行此段代码的输出是什么？</strong></p>
<p>Output: ExampleA. The first catch block alreay catch this exception. The second catch block will not be excuted.</p>
<p>(37) <strong>List、Set、Map是否继承自Collection接口？</strong> </p>
<p>List and Set classes are inherited from Collection Interface, but Map class is not.</p>
<p>(38) <strong>阐述ArrayList、Vector、LinkedList的存储性能和特性。</strong></p>
<p>ArrayList and Vector are stored in array type. They both allow insert according to index. But insertion should move elements. so search is fast while insetion is slow. Vector use synchronized keyword, so vector is thread safe, but its performance is worse than ArrayList. LinkedList is stored in double linked list type and insertion is fast. </p>
<p>ArrayList and LinkedList is not thread safe. So if multiple thread operate the same container, we can call the synchronizedList method in Collections class to guarentee thread sate.</p>
<p>(40) <strong>Collection和Collections的区别？</strong> </p>
<p>Collection is an interface, it is the super interface of Set and List.</p>
<p>Collections is a tool class, provides static method to help container operation, includes search, sort and thread sate method.</p>
<p>(41) <strong>List、Map、Set三个接口存取元素时，各有什么特点？</strong> </p>
<p>List can search element by index, it allows duplicate element. Set does not allow duplicate element. Set and Map have two versions: Hash and Tree. Add and remove of Hash version is O(1) time. For Tree version, insert or delete elements will reorder and remove duplicate according to element or key.</p>
<p>(42) <strong>TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</strong> </p>
<p>For TreeSet, object must override compareTo() method. </p>
<p>For TreeMap, object must implement Comparable interface to sort key.</p>
<p>There are two methods to implement sort method.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;        </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;            </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Student [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age - o.age; </div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Collections;</div><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();     </div><div class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"Hao LUO"</span>, <span class="number">33</span>));</div><div class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"XJ WANG"</span>, <span class="number">32</span>));</div><div class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"Bruce LEE"</span>, <span class="number">60</span>));</div><div class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"Bob YANG"</span>, <span class="number">22</span>));</div><div class="line"></div><div class="line">        <span class="comment">// 通过sort方法的第二个参数传入一个Comparator接口对象</span></div><div class="line">        <span class="comment">// 相当于是传入一个比较对象大小的算法到sort方法中</span></div><div class="line">        <span class="comment">// 由于Java中没有函数指针、仿函数、委托这样的概念</span></div><div class="line">        <span class="comment">// 因此要将一个算法传入一个方法中唯一的选择就是通过接口回调</span></div><div class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt; () &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> o1.getName().compareTo(o2.getName());    &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(Student stu : list) &#123;</div><div class="line">            System.out.println(stu);</div><div class="line">        &#125;</div><div class="line"><span class="comment">//      Output: </span></div><div class="line"><span class="comment">//      Student [name=Bob YANG, age=22]</span></div><div class="line"><span class="comment">//      Student [name=Bruce LEE, age=60]</span></div><div class="line"><span class="comment">//      Student [name=Hao LUO, age=33]</span></div><div class="line"><span class="comment">//      Student [name=XJ WANG, age=32]</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(43) <strong>Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</strong></p>
<p>The code sleep(2000); put thread aside for exactly twoo seconds. The code wait(2000), causes a wait up to 2 seconds. A thread could stop waiting earlier if it receives the notify() or notifyAll() call. The method wait() is defined in the class Object and the method sleep() is defined in the class Thread.</p>
<p>(44) <strong>线程的sleep()方法和yield()方法有什么区别？</strong></p>
<p>When a task invokes its yield() method, it returns to the ready state. When a task invokes its sleep() method, it returns to the waiting state.</p>
<p>(45) <strong>当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？</strong></p>
<p>No. Other threads can only access this object’s non-synchronized methods. </p>
<p>(46) <strong>请说出与线程同步以及线程调度相关的方法。</strong> </p>
<p>wait():switch a thread to a waiting(blocking) status, and release all the lock it holds.</p>
<p>sleep(): switch a thread to sleeping status.</p>
<p>notify(): wake up a thread in waiting status. But system cannot guarentee wake up which thread. It will noly randomly wake up a waiting thread.</p>
<p>notifyAll(): wake up all waiting threads. Let these threads compete for resource.  </p>

      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2016/10/04/Java-Question/" class="article-date">
  <time datetime="2016-10-04T13:55:54.000Z" itemprop="datePublished">2016-10-04</time>
</a>

        </li>
        
        
          <li>
            <span class="label">Tag:</span>
            
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>


          </li>
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/2016/10/08/Two-Sum/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Nuevo</strong>
      <div class="article-nav-title">
        
          Two-Sum
        
      </div>
    </a>
  
  
    <a href="/2016/10/02/Runnable-And-Thread/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Viejo</strong>
      <div class="article-nav-title">Runnable And Thread</div>
    </a>
  
</nav>


  
</article>




      </div>
      
    <footer id="footer" class="post-footer footer">
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>ipsum dolor sit amet, <strong>consectetur adipiscing elit.</strong> Fusce eget urna vitae velit <em>eleifend interdum at ac nisi. In nec ligula lacus. Cum sociis natoque</em> penatibus et magnis dis parturient montes, nascetur ridiculus mus. Sed eu cursus erat, ut dapibus quam. Post</p>


      </div>
    </footer>

      

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->







    </div>
  </body>
</html>
